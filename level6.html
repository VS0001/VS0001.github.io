<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Level 6 - Final Boss</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: #111;
    }
    #hudText {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
    }
    #backDashboardBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 16px;
      padding: 6px 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="game" width="800" height="600"></canvas>
  <div id="hudText">Coins: 0 | Lives: 3 | Time: 00:00</div>
  <button id="backDashboardBtn">Back to Dashboard</button>

  <!-- Touchscreen Controls -->
  <div id="touchControls" style="display: block;">
    <!-- Movement Controls -->
    <button id="leftBtn" style="position: absolute; bottom: 20px; left: 20px; width: 60px; height: 60px; background: rgba(0,255,255,0.7); border: none; border-radius: 50%; color: white; font-size: 24px;">‚Üê</button>
    <button id="rightBtn" style="position: absolute; bottom: 20px; right: 20px; width: 60px; height: 60px; background: rgba(0,255,255,0.7); border: none; border-radius: 50%; color: white; font-size: 24px;">‚Üí</button>

    <!-- Fire Button (center bottom) -->
    <button id="fireBtn" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 80px; height: 80px; background: rgba(255,0,0,0.7); border: none; border-radius: 50%; color: white; font-size: 16px; font-weight: bold;">FIRE</button>

    <!-- Auto-fire toggle -->
    <button id="autoFireBtn" style="position: absolute; top: 50px; right: 20px; padding: 10px; background: rgba(255,255,255,0.2); border: 1px solid white; border-radius: 5px; color: white;">Auto-Fire: OFF</button>

    <!-- Ability buttons (shown only if owned) -->
    <div id="abilityButtons" style="position: absolute; top: 100px; left: 20px; display: flex; flex-direction: column; gap: 10px;">
      <button id="minionBtn" style="display: none; padding: 10px; background: rgba(255,0,0,0.7); border: none; border-radius: 5px; color: white;">Minions (1)</button>
      <button id="freezeBtn" style="display: none; padding: 10px; background: rgba(0,0,255,0.7); border: none; border-radius: 5px; color: white;">Time Freeze (3)</button>
      <button id="smokeBtn" style="display: none; padding: 10px; background: rgba(128,128,128,0.7); border: none; border-radius: 5px; color: white;">Smoke Bomb (2)</button>
    </div>
  </div>



  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hudText");
    const backDashboardBtn = document.getElementById("backDashboardBtn");

    // Preload boss image
    const bossImage = new Image();
    bossImage.src = 'level6boss.png';

    function updateTotalScore(earned) {
      const current = parseInt(localStorage.getItem("totalScore") || "0");
      localStorage.setItem("totalScore", current + earned);
    }

    function formatTime(ms) {
      const s = Math.floor(ms / 1000);
      return `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
    }

    // Check if player completed Level 5
    const level5Complete = localStorage.getItem("level5Complete");
    const level6Eligible = localStorage.getItem("level6Eligible");
    if (level5Complete !== "true" && level6Eligible !== "true") {
      alert("You must complete Level 5 first to access the Final Boss!");
      window.location.href = "index.html";
    }

    // Game state
    const gameStartTime = parseInt(localStorage.getItem("gameTimeStart")) || Date.now();
    const gameMode = localStorage.getItem("gameMode") || "normal";
    
    // Game mode multipliers
    const bulletSpeedMultiplier = gameMode === "easy" ? 0.75 : gameMode === "hard" ? 1.5 : 1;
    const fireRateMultiplier = gameMode === "easy" ? 1 : gameMode === "hard" ? 1.5 : 1;
    
    let score = parseInt(localStorage.getItem("playerScore")) || 0;
    let lives = parseInt(localStorage.getItem("playerLives")) || 3;

    const avatar = localStorage.getItem("avatarEmoji") || "üöÄ";
    const trailColor = localStorage.getItem("trailColor");
    const tripleShot = localStorage.getItem("tripleShot") === "true";
    const doublePoints = localStorage.getItem("doublePoints") === "true";
    const speedBoost = parseInt(localStorage.getItem("speedBoost") || "0");
    const speedMultiplier = 1 + speedBoost * 0.1;
    const homingEnabled = localStorage.getItem("homingMissile") === "true";

    const extraLifeBonus = localStorage.getItem("extraLifeBonus") === "true";
    const regeneration = localStorage.getItem("regeneration") === "true";
    const x2Damage = localStorage.getItem("x2Damage") === "true";
    const minionClones = localStorage.getItem("minionClones") === "true";
    const minionHealthLevel = parseInt(localStorage.getItem("minionHealthLevel") || "0");
    const minionFireRateUpgrade = localStorage.getItem("minionFireRateUpgrade") === "true";
    const smokeBomb = localStorage.getItem("smokeBomb") === "true";
    const gracePeriod = true; // Always active
    const timeFreeze = localStorage.getItem("timeFreeze") === "true";
    const starShooter = localStorage.getItem("starShooter") === "true";
    const rewardScaleUp = localStorage.getItem("rewardScaleUp") === "true";

    const starBulletImg = new Image();
    starBulletImg.src = 'fancybullets.png';
    const fancyHomingImg = new Image();
    fancyHomingImg.src = 'fancyhomingmissile.png';

    // Cap max lives based on game mode - don't add extra life bonus here
    const maxLives = gameMode === "easy" ? 6 : gameMode === "hard" ? 2 : 4;

    let player = { x: 400, y: 550, width: 30, height: 30, cooldown: 0, invulnerable: gracePeriod ? 5000 : 0 };
    let keys = {};
    let bullets = [], cannonBalls = [], homingMissiles = [];
    let gameOver = false;
    let shotCount = 0;
    let homingCooldown = 0;
    const HOMING_COOLDOWN_TIME = 7000;
    let playerMinions = [], minionBullets = [], minionsSpawned = false;
    let smokeCooldown = parseInt(localStorage.getItem("smokeCooldown") || "0");
    let smokeActive = parseInt(localStorage.getItem("smokeActive") || "0");
    let freezeCooldown = parseInt(localStorage.getItem("timeFreezeCooldown") || "0");
    let freezeActive = parseInt(localStorage.getItem("timeFreezeActive") || "0");

    const boss = {
      x: 350, y: 100, width: 120, height: 120, health: 150, maxHealth: 150,
      invincibleTimer: 0, shootTimer: 0,
      moveTimer: 0, dx: 0,
      bulletStormTimer: 10000, bulletStormActive: false, bulletStormBurstTimer: 0,
      bulletStormBurstCount: 0, originalX: 350, jerkDirection: 1,
      coneAttackTimer: 8000, coneAttackActive: false
    };

    let cannons = [
      { x: 20, y: 40, shootTimer: 2500 },
      { x: 720, y: 40, shootTimer: 2500 }
    ];

    document.addEventListener("keydown", e => {
      keys[e.key] = true;
      // WASD movement mapping
      if (e.key === "w") keys["ArrowUp"] = true;
      if (e.key === "a") keys["ArrowLeft"] = true;
      if (e.key === "s") keys["ArrowDown"] = true;
      if (e.key === "d") keys["ArrowRight"] = true;
      
      if (e.key === "q" || e.key === "Q") {
        if (homingEnabled && homingCooldown <= 0) {
          homingMissiles.push({ x: player.x + 18, y: player.y, vx: 0, vy: -5 });
          homingCooldown = HOMING_COOLDOWN_TIME;
        }
      }
      if (e.key === "1") {
        if (minionClones && !minionsSpawned) {
          spawnPlayerMinions();
          minionsSpawned = true;
        }
      }
      if (e.key === "2") {
        if (smokeBomb && smokeCooldown <= 0) {
          smokeActive = 10000;
          smokeCooldown = 20000;
        }
      }
      if (e.key === "3") {
        if (timeFreeze && freezeCooldown <= 0) {
          freezeActive = 10000;
          freezeCooldown = 90000;
        }
      }
    });
    document.addEventListener("keyup", e => {
      keys[e.key] = false;
      // WASD movement mapping
      if (e.key === "w") keys["ArrowUp"] = false;
      if (e.key === "a") keys["ArrowLeft"] = false;
      if (e.key === "s") keys["ArrowDown"] = false;
      if (e.key === "d") keys["ArrowRight"] = false;
    });

    // Touchscreen support - show controls and setup events
    let autoFire = false;
    let autoFireInterval;

    // Show ability buttons if owned
    if (minionClones) {
      document.getElementById('minionBtn').style.display = 'block';
    }
    if (timeFreeze) {
      document.getElementById('freezeBtn').style.display = 'block';
    }
    if (smokeBomb) {
      document.getElementById('smokeBtn').style.display = 'block';
    }

    // Touch controls - both touch and mouse events
    document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys["ArrowLeft"] = true;
    });
    document.getElementById('leftBtn').addEventListener('touchend', (e) => {
      e.preventDefault();
      keys["ArrowLeft"] = false;
    });
    document.getElementById('leftBtn').addEventListener('mousedown', (e) => {
      e.preventDefault();
      keys["ArrowLeft"] = true;
    });
    document.getElementById('leftBtn').addEventListener('mouseup', (e) => {
      e.preventDefault();
      keys["ArrowLeft"] = false;
    });

    document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys["ArrowRight"] = true;
    });
    document.getElementById('rightBtn').addEventListener('touchend', (e) => {
      e.preventDefault();
      keys["ArrowRight"] = false;
    });
    document.getElementById('rightBtn').addEventListener('mousedown', (e) => {
      e.preventDefault();
      keys["ArrowRight"] = true;
    });
    document.getElementById('rightBtn').addEventListener('mouseup', (e) => {
      e.preventDefault();
      keys["ArrowRight"] = false;
    });

    // Fire button
    document.getElementById('fireBtn').addEventListener('touchstart', () => {
        if (player.cooldown <= 0 && !gameOver) {
            keys[" "] = true;
            setTimeout(() => keys[" "] = false, 50);
        }
    });
    document.getElementById('fireBtn').addEventListener('mousedown', () => {
        if (player.cooldown <= 0 && !gameOver) {
            keys[" "] = true;
            setTimeout(() => keys[" "] = false, 50);
        }
    });
    document.getElementById('fireBtn').addEventListener('touchend', () => {});
    document.getElementById('fireBtn').addEventListener('mouseup', () => {});

    // Auto-fire toggle
    document.getElementById('autoFireBtn').addEventListener('click', () => {
      autoFire = !autoFire;
      document.getElementById('autoFireBtn').textContent = autoFire ? 'Auto-Fire: ON' : 'Auto-Fire: OFF';

      if (autoFire) {
        autoFireInterval = setInterval(() => {
          if (!gameOver && keys[" "] !== true) {
            keys[" "] = true;
            setTimeout(() => keys[" "] = false, 50);
          }
        }, 200);
      } else {
        clearInterval(autoFireInterval);
      }
    });

    // Ability buttons
    document.getElementById('minionBtn').addEventListener('click', () => {
      if (minionClones && !minionsSpawned) {
        spawnPlayerMinions();
        minionsSpawned = true;
      }
    });

    document.getElementById('freezeBtn').addEventListener('click', () => {
      if (timeFreeze && freezeCooldown <= 0) {
        freezeActive = 10000;
        freezeCooldown = 90000;
      }
    });

    document.getElementById('smokeBtn').addEventListener('click', () => {
      if (smokeBomb && smokeCooldown <= 0) {
        smokeActive = 10000;
        smokeCooldown = 20000;
      }
    });

    // Click anywhere to shoot
    document.addEventListener('click', (e) => {
      if (!e.target.tagName || e.target.tagName.toLowerCase() !== 'button') {
        if (player.cooldown <= 0 && !gameOver) {
          keys[" "] = true;
          setTimeout(() => keys[" "] = false, 50);
        }
      }
    });

    function spawnPlayerMinions() {
      const minionHealthLevel = parseInt(localStorage.getItem("minionHealthLevel") || "0");
      const minionFireRateUpgrade = localStorage.getItem("minionFireRateUpgrade") === "true";
      for (let i = 0; i < 3; i++) {
        playerMinions.push({
          x: player.x + (i - 1) * 60,
          y: player.y - 50,
          width: 30,
          height: 30,
          health: 1 + minionHealthLevel,
          maxHealth: 1 + minionHealthLevel,
          direction: 1,
          shootTimer: minionFireRateUpgrade ? 1000 : 2000
        });
      }
    }

    function drawEmoji(x, y, emoji, size = "30px") {
      ctx.font = size + " serif";
      ctx.fillStyle = "white";
      ctx.fillText(emoji, x, y);
    }

    function shootAtPlayer(from) {
      const dx = player.x + 20 - (from.x + 20);
      const dy = player.y - (from.y + 20);
      const mag = Math.sqrt(dx * dx + dy * dy);
      const speed = 12 * bulletSpeedMultiplier;
      return {
        x: from.x + 20,
        y: from.y + 20,
        dx: (dx / mag) * speed,
        dy: (dy / mag) * speed
      };
    }

    function update() {
      if (gameOver) return;

      if (keys["ArrowLeft"]) player.x -= 5 * speedMultiplier;
      if (keys["ArrowRight"]) player.x += 5 * speedMultiplier;
      if (keys["ArrowUp"]) player.y -= 3 * speedMultiplier;
      if (keys["ArrowDown"]) player.y += 3 * speedMultiplier;

      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(400, Math.min(canvas.height - player.height, player.y));

      // Update cooldowns
      player.invulnerable = Math.max(0, player.invulnerable - 16);
      smokeCooldown = Math.max(0, smokeCooldown - 16);
      smokeActive = Math.max(0, smokeActive - 16);
      freezeCooldown = Math.max(0, freezeCooldown - 16);
      freezeActive = Math.max(0, freezeActive - 16);

      // Update player minions
      playerMinions.forEach((minion, mi) => {
        minion.x += minion.direction * 2;
        if (minion.x <= 0 || minion.x + minion.width >= canvas.width) {
          minion.direction *= -1;
        }

        minion.shootTimer -= 16;
        if (minion.shootTimer <= 0) {
          bullets.push({ x: minion.x + 15, y: minion.y, dx: 0 });
          minion.shootTimer = minionFireRateUpgrade ? 1000 : 2000;
        }
      });

      player.cooldown -= 16;
      if (keys[" "] && player.cooldown <= 0) {
        shotCount++;
        if (shotCount % 5 === 0 && homingEnabled) {
          // Every 5th shot is a homing missile (only if purchased)
          homingMissiles.push({ x: player.x + 18, y: player.y, vx: 0, vy: -5 });
        } else {
          if (tripleShot) {
            bullets.push({ x: player.x + 18, y: player.y, dx: -1 });
            bullets.push({ x: player.x + 18, y: player.y, dx: 0 });
            bullets.push({ x: player.x + 18, y: player.y, dx: 1 });
          } else {
            bullets.push({ x: player.x + 18, y: player.y, dx: 0 });
          }
        }
        // Default fire rate is 400ms
        player.cooldown = 400;
      }

      bullets.forEach(b => {
        b.x += (b.dx || 0) * 2;
        b.y -= 10;
      });
      bullets = bullets.filter(b => b.y > 0);

      cannonBalls.forEach(b => {
        b.x += b.dx;
        b.y += b.dy;
      });
      cannonBalls = cannonBalls.filter(b =>
        b.x > 0 && b.x < canvas.width && b.y > 0 && b.y < canvas.height
      );

      homingCooldown -= 16;
      const fancyHomingActive = localStorage.getItem("fancyHomingMissile") === "true";
      const homingSpeed = fancyHomingActive ? 12 : 6;
      const homingDamage = (fancyHomingActive ? 4 : 2) * (x2Damage ? 2 : 1);

      homingMissiles.forEach((m, i) => {
        // Boss is always the highest health target in this level
        const target = boss;
        const dx = target.x + target.width/2 - m.x;
        const dy = target.y + target.height/2 - m.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 20) {
          homingMissiles.splice(i, 1);
          target.health -= homingDamage;
          target.invincibleTimer = 1000;
        } else {
          m.x += (dx / dist) * homingSpeed;
          m.y += (dy / dist) * homingSpeed;
        }
      });
      homingMissiles = homingMissiles.filter(m => m.y > 0);

      // Boss logic
      boss.invincibleTimer = Math.max(0, boss.invincibleTimer - 16);

      if (!freezeActive) {
        boss.bulletStormTimer -= 16;
        boss.coneAttackTimer -= 16;
      }

      // Bullet Storm attack every 10 seconds
      if (boss.bulletStormTimer <= 0 && !boss.bulletStormActive && !freezeActive) {
        boss.bulletStormActive = true;
        boss.bulletStormBurstTimer = 0;
        boss.bulletStormBurstCount = 0;
        boss.originalX = boss.x;
        boss.bulletStormTimer = 10000; // Reset timer
      }

      // Cone attack every 8 seconds
      if (boss.coneAttackTimer <= 0 && !boss.bulletStormActive && !freezeActive && !smokeActive) {
        // Fire 5 bullets in a cone shape towards player
        const playerCenterX = player.x + player.width / 2;
        const playerCenterY = player.y + player.height / 2;
        const bossCenterX = boss.x + boss.width / 2;
        const bossCenterY = boss.y + boss.height / 2;

        const baseAngle = Math.atan2(playerCenterY - bossCenterY, playerCenterX - bossCenterX);
        const coneSpread = Math.PI / 6; // 30 degree spread

        for (let i = 0; i < 5; i++) {
          const angle = baseAngle + (i - 2) * (coneSpread / 4);
          cannonBalls.push({
            x: bossCenterX,
            y: bossCenterY,
            dx: Math.cos(angle) * 8,
            dy: Math.sin(angle) * 8
          });
        }
        boss.coneAttackTimer = 8000; // Reset timer
      }

      if (boss.bulletStormActive) {
        // Rapid jerking movement during bullet storm
        boss.x = boss.originalX + Math.sin(Date.now() * 0.02) * 40;
        boss.bulletStormBurstTimer -= 16;

        if (boss.bulletStormBurstTimer <= 0) {
          // Fire 10 bullets in quick succession
          for (let i = 0; i < 10; i++) {
            const angle = (Math.PI * 2 * i) / 10;
            cannonBalls.push({
              x: boss.x + boss.width/2,
              y: boss.y + boss.height/2,
              dx: Math.cos(angle) * 10,
              dy: Math.sin(angle) * 10
            });
          }
          boss.bulletStormBurstCount++;
          boss.bulletStormBurstTimer = 500; // 0.5 second between bursts

          if (boss.bulletStormBurstCount >= 5) { // 5 bursts total
            boss.bulletStormActive = false;
          }
        }
      } else {
        // Normal movement and shooting when not in bullet storm
        if (!freezeActive) {
          boss.shootTimer -= 16;
          boss.moveTimer -= 16;
        }

        if (boss.shootTimer <= 0 && !freezeActive && !smokeActive) {
          cannonBalls.push(shootAtPlayer(boss));
          cannonBalls.push(shootAtPlayer(boss));
          cannonBalls.push(shootAtPlayer(boss));
          boss.shootTimer = 500 / fireRateMultiplier;
        }

        if (boss.moveTimer <= 0) {
          boss.dx = (Math.random() > 0.5 ? 1 : -1) * (Math.random() * 6 + 2);
          boss.moveTimer = Math.random() * 400 + 200;
        }
        if (!freezeActive) {
          boss.x += boss.dx;
          boss.x = Math.max(0, Math.min(canvas.width - boss.width, boss.x));
          if (boss.x <= 0 || boss.x + boss.width >= canvas.width) boss.dx *= -1;
        }
      }

      // Cannons
      cannons.forEach(c => {
        if (!freezeActive) {
          c.shootTimer -= 16;
        }
        if (c.shootTimer <= 0 && !freezeActive && !smokeActive) {
          cannonBalls.push(shootAtPlayer(c));
          c.shootTimer = 2500 / fireRateMultiplier;
        }
      });

      bullets.forEach((b, bi) => {
        if (bi >= bullets.length) return; // Bullet may have been removed already
        if (
          b.x < boss.x + boss.width && b.x + 4 > boss.x &&
          b.y < boss.y + boss.height && b.y + 10 > boss.y
        ) {
          if (boss.invincibleTimer <= 0) {
            const bulletDamage = x2Damage ? 2 : 1;
            boss.health -= bulletDamage;
            boss.invincibleTimer = 1000;
          }
          bullets.splice(bi, 1);

          if (boss.health <= 0) {
            gameOver = true;
            score += 1000; // Boss doesn't get double points
            cannons = []; // Remove cannons when boss is defeated

            // Award 10 diamonds for defeating final boss
            const currentDiamonds = parseInt(localStorage.getItem("playerDiamonds") || "0");
            localStorage.setItem("playerDiamonds", (currentDiamonds + 10).toString());

            localStorage.setItem("level6Complete", "true");
            updateTotalScore(score);

            const maxLives = gameMode === "easy" ? 6 : gameMode === "hard" ? 2 : 4;
            let finalLives = lives;
            // Only add 1 life with regeneration if player is below max lives
            if (regeneration && finalLives < maxLives) {
              finalLives = Math.min(finalLives + 1, maxLives);
            }
            localStorage.setItem("playerLives", finalLives);

            localStorage.removeItem("level6Eligible");
            const elapsed = Date.now() - gameStartTime;
            const result = { time: elapsed, score, lives, gameMode, date: new Date().toLocaleString() };
            const board = JSON.parse(localStorage.getItem("scoreboard") || "[]");
            board.push(result);
            board.sort((a, b) => a.time - b.time);
            localStorage.setItem("scoreboard", JSON.stringify(board));

            setTimeout(() => {
              const winDiv = document.createElement('div');
              winDiv.style.cssText = 'position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; flex-direction: column; background: rgba(0,0,0,0.8); font-size: 48px; color: white;';
              winDiv.innerHTML = '<div>Level 6 Complete!</div><div style="font-size: 24px; margin-top: 20px;">Final Score: ' + score + '</div><button id="toLevel7Btn" style="font-size: 24px; margin-top: 20px; padding: 10px 20px; cursor: pointer;">Next Level</button>';
              document.body.appendChild(winDiv);
              
              document.getElementById('toLevel7Btn').onclick = () => {
                localStorage.setItem("playerScore", score);
                localStorage.setItem("playerLives", lives);
                localStorage.setItem("gameTimeStart", Date.now());
                window.location.href = "level7.html";
              };
            }, 500);
          }
        }
      });

      cannonBalls.forEach((b, bi) => {
        if (b.x < player.x + player.width && b.x + 8 > player.x &&
            b.y < player.y + player.height && b.y + 16 > player.y) {
          cannonBalls.splice(bi, 1);
          if (player.invulnerable <= 0) {
            lives--;
            if (lives <= 0) {
              gameOver = true;
              updateTotalScore(score);
              localStorage.removeItem("level6Eligible");
              const elapsed = Date.now() - gameStartTime;
              const result = { time: elapsed, score, lives: 0, gameMode, date: new Date().toLocaleString() };
              const board = JSON.parse(localStorage.getItem("scoreboard") || "[]");
              board.push(result);
              board.sort((a, b) => a.time - b.time);
              localStorage.setItem("scoreboard", JSON.stringify(board));
              alert("You lost!");
              window.location.href = "dashboard.html";
            } else {
              // Reset player position and grant invincibility
              player.x = 400;
              player.y = 550;
              cannonBalls = [];
              player.invulnerable = gracePeriod ? 2000 : 1000;
            }
          }
        }
      });

      const elapsed = Date.now() - gameStartTime;
      let cooldownText = "";
      if (smokeCooldown > 0) {
        cooldownText += ` | Smoke: ${Math.ceil(smokeCooldown / 1000)}s`;
      }
      if (freezeCooldown > 0) {
        cooldownText += ` | Freeze: ${Math.ceil(freezeCooldown / 1000)}s`;
      }
      hud.innerText = `Coins: ${score} | Lives: ${lives} | Time: ${formatTime(elapsed)}${cooldownText}`;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw grace period effect
      if (player.invulnerable > 0) {
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "yellow";
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.globalAlpha = 1;
      }

      // Draw smoke effect
      if (smokeActive > 0) {
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = "gray";
        ctx.fillRect(player.x - 20, player.y - 20, player.width + 40, player.height + 40);
        ctx.globalAlpha = 1;
      }

      if (trailColor) {
        ctx.strokeStyle = trailColor;
        ctx.beginPath();
        ctx.moveTo(player.x + 20, player.y + 30);
        ctx.lineTo(player.x + 10, player.y + 50);
        ctx.lineTo(player.x + 30, player.y + 50);
        ctx.stroke();
      }

      drawEmoji(player.x, player.y + 24, avatar);

      // Draw player minions
      playerMinions.forEach(minion => {
        drawEmoji(minion.x, minion.y + 20, "ü§ñ", "20px");
      });

      // Boss health bar
      ctx.fillStyle = "gray";
      ctx.fillRect(boss.x, boss.y - 20, boss.width, 10);
      ctx.fillStyle = "red";
      ctx.fillRect(boss.x, boss.y - 20, boss.width * (boss.health / boss.maxHealth), 10);

      // Draw boss image
      ctx.drawImage(bossImage, boss.x, boss.y, boss.width, boss.height);

      cannons.forEach(c => drawEmoji(c.x, c.y + 24, "üõ°Ô∏è", "28px"));

      bullets.forEach(b => {
        if (starShooter) {
          ctx.drawImage(starBulletImg, b.x - 6, b.y - 6, 16, 16);
        } else {
          ctx.fillStyle = "white";
          ctx.fillRect(b.x, b.y, 4, 10);
        }
      });

      ctx.fillStyle = "red";
      cannonBalls.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, 10, 0, Math.PI * 2);
        ctx.fill();
      });

      const fancyHomingActive = localStorage.getItem("fancyHomingMissile") === "true";
      if (fancyHomingActive) {
        homingMissiles.forEach(m => {
          ctx.drawImage(fancyHomingImg, m.x - 20, m.y - 20, 40, 40);
        });
      } else {
        ctx.fillStyle = "cyan";
        homingMissiles.forEach(m => {
          ctx.beginPath();
          ctx.arc(m.x, m.y, 15, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
    }

    function loop() {
      update();
      draw();
      if (!gameOver) requestAnimationFrame(loop);
    }

    loop(); // Start the game loop

    backDashboardBtn.onclick = () => {
      updateTotalScore(score);
      window.location.href = "dashboard.html";
    };
  </script>
</body>
</html>
