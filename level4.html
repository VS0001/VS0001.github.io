<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Emoji Space Invaders - Level 4</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: #111;
    }
    #hudText {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 20px;
    }
    #backDashboardBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 16px;
      padding: 6px 12px;
      cursor: pointer;
    }
    #reinforceFlash {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: red;
      display: none;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    #winScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 36px;
      text-align: center;
    }
    #winScreen button {
      font-size: 24px;
      padding: 10px 20px;
      margin-top: 20px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <canvas id="game" width="800" height="600"></canvas>
  <div id="hudText">Coins: 0 | Lives: 3 | Time: 00:00</div>
  <div id="reinforceFlash">REINFORCEMENTS INCOMING!</div>
  <button id="backDashboardBtn">Back to Dashboard</button>
  <div id="winScreen">
    <h2>Level Complete!</h2>
    <p id="winScreenScore">Score: 0</p>
    <p id="winScreenTime">Time: 00:00</p>
    <p id="winScreenLives">Lives Remaining: 3</p>
    <button id="nextLevelBtn">Next Level</button>
    <button id="dashboardBtn">Back to Dashboard</button>
  </div>

  <!-- Touchscreen Controls -->
  <div id="touchControls" style="display: block;">
    <button id="leftBtn" style="position: absolute; bottom: 20px; left: 20px; width: 60px; height: 60px; background: rgba(0,255,255,0.7); border: none; border-radius: 50%; color: white; font-size: 24px;">‚Üê</button>
    <button id="rightBtn" style="position: absolute; bottom: 20px; right: 20px; width: 60px; height: 60px; background: rgba(0,255,255,0.7); border: none; border-radius: 50%; color: white; font-size: 24px;">‚Üí</button>
    <button id="fireBtn" style="position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 80px; height: 80px; background: rgba(255,0,0,0.7); border: none; border-radius: 50%; color: white; font-size: 16px; font-weight: bold;">FIRE</button>
    <button id="autoFireBtn" style="position: absolute; top: 50px; right: 20px; padding: 10px; background: rgba(255,255,255,0.2); border: 1px solid white; border-radius: 5px; color: white;">Auto-Fire: OFF</button>
    <div id="abilityButtons" style="position: absolute; top: 100px; left: 20px; display: flex; flex-direction: column; gap: 10px;">
      <button id="minionBtn" style="display: none; padding: 10px; background: rgba(255,0,0,0.7); border: none; border-radius: 5px; color: white;">Minions (M)</button>
      <button id="freezeBtn" style="display: none; padding: 10px; background: rgba(0,0,255,0.7); border: none; border-radius: 5px; color: white;">Time Freeze (E)</button>
      <button id="smokeBtn" style="display: none; padding: 10px; background: rgba(128,128,128,0.7); border: none; border-radius: 5px; color: white;">Smoke Bomb (W)</button>
    </div>
  </div>

  <script>
    // --- Game Configuration and State ---
    const levelData = {
      level4: {
        aliens: { initialHealth: 3, fireImmediately: true },
        maxLives: { easy: 6, medium: 4, hard: 2 }
      }
    };

    const currentLevel = "level4";
    const levelConfig = levelData[currentLevel];

    const level3Complete = localStorage.getItem("level3Complete");
    if (level3Complete !== "true" && currentLevel === "level4") {
      alert("You must complete Level 3 first to access this level!");
      window.location.href = "dashboard.html";
    }

    function updateTotalScore(earned) {
      const current = parseInt(localStorage.getItem("totalScore") || "0");
      localStorage.setItem("totalScore", current + earned);
    }

    function formatTime(ms) {
      const s = Math.floor(ms / 1000);
      return `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
    }

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const hud = document.getElementById("hudText");
    const flashMsg = document.getElementById("reinforceFlash");
    const backDashboardBtn = document.getElementById("backDashboardBtn");
    const winScreen = document.getElementById("winScreen");
    const nextLevelBtn = document.getElementById("nextLevelBtn");
    const dashboardBtn = document.getElementById("dashboardBtn");
    const winScreenScore = document.getElementById("winScreenScore");
    const winScreenTime = document.getElementById("winScreenTime");
    const winScreenLives = document.getElementById("winScreenLives");

    const gameStartTime = parseInt(localStorage.getItem("gameTimeStart")) || Date.now();
    const gameMode = localStorage.getItem("gameMode") || "normal";
    
    // Game mode multipliers
    const bulletSpeedMultiplier = gameMode === "easy" ? 0.75 : gameMode === "hard" ? 1.5 : 1;
    const fireRateMultiplier = gameMode === "easy" ? 1 : gameMode === "hard" ? 1.5 : 1;
    
    const avatar = localStorage.getItem("avatarEmoji") || "üöÄ";
    const trailColor = localStorage.getItem("trailColor");
    const tripleShot = localStorage.getItem("tripleShot") === "true";
    const doublePoints = localStorage.getItem("doublePoints") === "true";
    const speedBoost = parseInt(localStorage.getItem("speedBoost") || "0");
    const speedMultiplier = 1 + speedBoost * 0.1;
    const homingEnabled = localStorage.getItem("homingMissile") === "true";
    const starShooter = localStorage.getItem("starShooter") === "true";
    
    const starBulletImg = new Image();
    starBulletImg.src = 'fancybullets.png';
    const fancyHomingImg = new Image();
    fancyHomingImg.src = 'fancyhomingmissile.png';
    
    const extraLifeBonus = localStorage.getItem("extraLifeBonus") === "true";
    const regeneration = localStorage.getItem("regeneration") === "true";
    const x2Damage = localStorage.getItem("x2Damage") === "true";
    const minionClones = localStorage.getItem("minionClones") === "true";
    const minionHealthLevel = parseInt(localStorage.getItem("minionHealthLevel") || "0");
    const minionFireRateUpgrade = localStorage.getItem("minionFireRateUpgrade") === "true";
    const smokeBomb = localStorage.getItem("smokeBomb") === "true";
    const gracePeriod = localStorage.getItem("gracePeriod") === "true";
    const timeFreeze = localStorage.getItem("timeFreeze") === "true";
    const rewardScaleUp = localStorage.getItem("rewardScaleUp") === "true"; // New upgrade

    let score = parseInt(localStorage.getItem("playerScore")) || 0;
    let initialLives = parseInt(localStorage.getItem("playerLives")) || 3;
    
    const maxLivesForLevel = levelConfig.maxLives[gameMode] !== undefined ? levelConfig.maxLives[gameMode] : (gameMode === "easy" ? 6 : gameMode === "normal" ? 4 : 2);
    let playerLives = initialLives;
    
    // Only add extra life bonus if we're below the cap
    if (extraLifeBonus && playerLives < maxLivesForLevel) {
      playerLives = Math.min(playerLives + 1, maxLivesForLevel);
    }

    let player = { x: 400, y: 550, width: 32, height: 32, lives: playerLives, cooldown: 0, invulnerable: gracePeriod ? 5000 : 0 };
    let bullets = [], cannonBalls = [], homingMissiles = [], keys = {};
    let aliens = [], playerMinions = [], minionBullets = [], direction = 1, gameOver = false;
    let shotCount = 0, homingCooldown = 0, smokeCooldown = 0, smokeActive = 0, freezeCooldown = 0, freezeActive = 0;
    let minionsSpawned = false;
    const HOMING_COOLDOWN_TIME = 7000;

    const cannon = {
      x: 380, y: 15, width: 32, height: 32, health: 15,
      shootTimer: 1500
    };

    function spawnAliens() {
      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 14; c++) {
          aliens.push({
            x: 20 + c * 55,
            y: 60 + r * 40,
            width: 32,
            height: 32,
            health: levelConfig.aliens.initialHealth,
            shootTimer: levelConfig.aliens.fireImmediately ? 100 : Math.random() * 6000 + 1500
          });
        }
      }
    }

    function spawnPlayerMinions() {
      for (let i = 0; i < 3; i++) {
        playerMinions.push({
          x: player.x + (i - 1) * 60,
          y: player.y - 50,
          width: 30,
          height: 30,
          health: 1 + minionHealthLevel,
          maxHealth: 1 + minionHealthLevel,
          direction: 1,
          shootTimer: minionFireRateUpgrade ? 1000 : 2000
        });
      }
    }

    function drawEmoji(x, y, emoji) {
      ctx.font = "24px serif";
      ctx.fillText(emoji, x, y);
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (player.invulnerable > 0) {
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = "yellow";
        ctx.fillRect(player.x, player.y, player.width, player.height);
        ctx.globalAlpha = 1;
      }

      if (smokeActive > 0) {
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = "gray";
        ctx.fillRect(player.x - 20, player.y - 20, player.width + 40, player.height + 40);
        ctx.globalAlpha = 1;
      }

      if (trailColor) {
        ctx.strokeStyle = trailColor;
        ctx.beginPath();
        ctx.moveTo(player.x + 16, player.y + 16);
        ctx.lineTo(player.x - 15, player.y + 35);
        ctx.lineTo(player.x + 47, player.y + 35);
        ctx.stroke();
      }

      drawEmoji(player.x, player.y, avatar);

      playerMinions.forEach(minion => {
        drawEmoji(minion.x, minion.y, "ü§ñ");
      });

      aliens.forEach(a => {
        let emoji = "üëæ";
        if (a.health === 5) emoji = "üë∫";
        else if (a.health === 4) emoji = "üíÄ";
        else if (a.health === 3) emoji = "üòà";
        else if (a.health === 2) emoji = "üëΩ";
        drawEmoji(a.x, a.y, emoji);
      });

      if (cannon.health > 0) drawEmoji(cannon.x, cannon.y, "üõ°Ô∏è");

      bullets.forEach(b => {
        if (starShooter) {
          ctx.drawImage(starBulletImg, b.x - 6, b.y - 6, 16, 16);
        } else {
          ctx.fillStyle = "white";
          ctx.fillRect(b.x, b.y, 4, 10);
        }
      });

      ctx.fillStyle = "red";
      cannonBalls.forEach(b =>
        ctx.fillRect(b.x, b.y, b.width || 8, b.height || 16)
      );

      ctx.fillStyle = "white";
      minionBullets.forEach(b => ctx.fillRect(b.x, b.y, 3, 8));

      const fancyHomingActive = localStorage.getItem("fancyHomingMissile") === "true";
      if (fancyHomingActive) {
        homingMissiles.forEach(m => {
          ctx.drawImage(fancyHomingImg, m.x - 20, m.y - 20, 40, 40);
        });
      } else {
        ctx.fillStyle = "cyan";
        homingMissiles.forEach(m => {
          ctx.beginPath();
          ctx.arc(m.x, m.y, 15, 0, 2 * Math.PI);
          ctx.fill();
        });
      }
    }

    function shootCannonball(from) {
      const dx = player.x + 16 - (from.x + 16);
      const dy = player.y - (from.y + 16);
      const mag = Math.sqrt(dx * dx + dy * dy);
      const speed = 10 * bulletSpeedMultiplier;

      cannonBalls.push({
        x: from.x + 16,
        y: from.y + 16,
        dx: (dx / mag) * speed,
        dy: (dy / mag) * speed,
        width: 8,
        height: 16
      });
    }

    function update() {
      if (gameOver) return;

      if (keys["ArrowLeft"]) player.x -= 5 * speedMultiplier;
      if (keys["ArrowRight"]) player.x += 5 * speedMultiplier;
      if (keys["ArrowUp"]) player.y -= 3 * speedMultiplier;
      if (keys["ArrowDown"]) player.y += 3 * speedMultiplier;

      player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
      player.y = Math.max(520, Math.min(canvas.height - player.height, player.y));

      player.invulnerable = Math.max(0, player.invulnerable - 16);
      smokeCooldown = Math.max(0, smokeCooldown - 16);
      smokeActive = Math.max(0, smokeActive - 16);
      freezeCooldown = Math.max(0, freezeCooldown - 16);
      freezeActive = Math.max(0, freezeActive - 16);

      playerMinions.forEach((minion, mi) => {
        if (!freezeActive) {
          minion.x += minion.direction * 2;
          if (minion.x <= 0 || minion.x + minion.width >= canvas.width) {
            minion.direction *= -1;
          }

          minion.shootTimer -= 16;
          if (minion.shootTimer <= 0) {
            minionBullets.push({ x: minion.x + 15, y: minion.y });
            minion.shootTimer = minionFireRateUpgrade ? 1000 : 2000;
          }
        }
      });

      minionBullets.forEach(b => b.y -= 8);
      minionBullets = minionBullets.filter(b => b.y > 0);

      player.cooldown -= 16;
      if (keys[" "] && player.cooldown <= 0) {
        shotCount++;
        if (shotCount % 5 === 0 && homingEnabled) {
          homingMissiles.push({ x: player.x + 14, y: player.y, vx: 0, vy: -5 });
        } else {
          if (tripleShot) {
            bullets.push({ x: player.x + 14, y: player.y, dx: -1 });
            bullets.push({ x: player.x + 14, y: player.y, dx: 0 });
            bullets.push({ x: player.x + 14, y: player.y, dx: 1 });
          } else {
            bullets.push({ x: player.x + 14, y: player.y, dx: 0 });
          }
        }
        player.cooldown = 400;
      }

      bullets.forEach(b => {
        b.x += (b.dx || 0) * 2;
        b.y -= 10;
      });
      bullets = bullets.filter(b => b.y > 0);

      cannonBalls.forEach(b => {
        b.x += b.dx;
        b.y += b.dy;
      });
      cannonBalls = cannonBalls.filter(b =>
        b.x > 0 && b.x < canvas.width && b.y > 0 && b.y < canvas.height
      );

      homingCooldown -= 16;
      const fancyHomingActive = localStorage.getItem("fancyHomingMissile") === "true";
      const homingSpeed = fancyHomingActive ? 12 : 6;
      const homingDamage = (fancyHomingActive ? 4 : 2) * (x2Damage ? 2 : 1);
      
      homingMissiles.forEach((m, i) => {
        let target = null;
        let maxHealth = 0;

        [...aliens].concat(cannon.health > 0 ? [cannon] : []).forEach(t => {
          if (t.health > maxHealth) {
            maxHealth = t.health;
            target = t;
          }
        });

        if (target) {
          const dx = target.x + target.width/2 - m.x;
          const dy = target.y + target.height/2 - m.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < 20) {
            homingMissiles.splice(i, 1);
            const originalHealth = target.health;
            target.health -= homingDamage;
            if (target === cannon && target.health <= 0) {
              score += doublePoints ? 10 : 5;
            } else if (aliens.includes(target) && target.health <= 0) {
              aliens.splice(aliens.indexOf(target), 1);
              const basePoints = rewardScaleUp ? originalHealth : 1;
              score += doublePoints ? basePoints * 2 : basePoints;
            }
          } else {
            m.x += (dx / dist) * homingSpeed;
            m.y += (dy / dist) * homingSpeed;
          }
        } else {
          m.y -= (fancyHomingActive ? 10 : 5);
        }
      });
      homingMissiles = homingMissiles.filter(m => m.y > 0);

      let edgeHit = false;
      if (!freezeActive) {
        aliens.forEach(a => {
          a.x += 1.5 * direction;
          if (a.x <= 0 || a.x + a.width >= canvas.width) edgeHit = true;
          a.shootTimer -= 16;

          if (a.shootTimer <= 0 && !smokeActive) {
            cannonBalls.push({
              x: a.x + 16,
              y: a.y + a.height,
              dx: 0,
              dy: 6 * bulletSpeedMultiplier,
              width: 4,
              height: 10
            });
            const baseInterval = Math.random() * 3000 + 4500;
            a.shootTimer = baseInterval / fireRateMultiplier;
          }
        });
        if (edgeHit) direction *= -1;
      }

      bullets.forEach((b, bi) => {
        aliens.forEach((a, ai) => {
          if (b.x < a.x + a.width && b.x + 4 > a.x &&
              b.y < a.y + a.height && b.y + 10 > a.y) {
            const originalHealth = a.health;
            const bulletDamage = x2Damage ? 2 : 1;
            a.health -= bulletDamage;
            if (a.health <= 0) {
              aliens.splice(ai, 1);
              const basePoints = rewardScaleUp ? originalHealth : 1;
              score += doublePoints ? basePoints * 2 : basePoints;
            }
            bullets.splice(bi, 1);
          }
        });

        if (cannon.health > 0 &&
            b.x < cannon.x + cannon.width && b.x + 4 > cannon.x &&
            b.y < cannon.y + cannon.height && b.y + 10 > cannon.y) {
          bullets.splice(bi, 1);
          const bulletDamage = x2Damage ? 2 : 1;
          cannon.health -= bulletDamage;
          if (cannon.health <= 0) score += doublePoints ? 10 : 5;
        }
      });

      minionBullets.forEach((mb, mbi) => {
        aliens.forEach((a, ai) => {
          if (mb.x < a.x + a.width && mb.x + 3 > a.x &&
              mb.y < a.y + a.height && mb.y + 8 > a.y) {
            const originalHealth = a.health;
            const minionBulletDamage = x2Damage ? 2 : 1;
            a.health -= minionBulletDamage;
            if (a.health <= 0) {
              aliens.splice(ai, 1);
              const basePoints = rewardScaleUp ? originalHealth : 1;
              score += doublePoints ? basePoints * 2 : basePoints;
            }
            minionBullets.splice(mbi, 1);
          }
        });

        if (cannon.health > 0 &&
            mb.x < cannon.x + cannon.width && mb.x + 3 > cannon.x &&
            mb.y < cannon.y + cannon.height && mb.y + 8 > cannon.y) {
          minionBullets.splice(mbi, 1);
          const minionBulletDamage = x2Damage ? 2 : 1;
          cannon.health -= minionBulletDamage;
          if (cannon.health <= 0) score += doublePoints ? 10 : 5;
        }
      });

      cannonBalls.forEach((b, bi) => {
        if (b.x < player.x + player.width && b.x + 8 > player.x &&
            b.y < player.y + player.height && b.y + 16 > player.y) {
          cannonBalls.splice(bi, 1);
          if (player.invulnerable <= 0) {
            player.lives--;
            if (player.lives <= 0) {
              gameOver = true;
              updateTotalScore(score);
              alert("Game Over!");
              window.location.href = "dashboard.html";
            } else {
              player.x = 400;
              player.y = 550;
              cannonBalls = [];
              player.invulnerable = gracePeriod ? 2000 : 1000;
            }
          }
        }
      });

      cannonBalls.forEach((b, bi) => {
        playerMinions.forEach((minion, mi) => {
          if (b.x < minion.x + minion.width && b.x + 8 > minion.x &&
              b.y < minion.y + minion.height && b.y + 16 > minion.y) {
            cannonBalls.splice(bi, 1);
            minion.health--;
            if (minion.health <= 0) {
              playerMinions.splice(mi, 1);
            }
          }
        });
      });

      if (!freezeActive && cannon.health > 0) {
        cannon.shootTimer -= 16;
        if (cannon.shootTimer <= 0 && !smokeActive) {
          shootCannonball(cannon);
          cannon.shootTimer = 1500 / fireRateMultiplier;
        }
      }

      const allDead = aliens.length === 0 && cannon.health <= 0;
      if (allDead && !gameOver) {
        gameOver = true;
        localStorage.setItem("level4Complete", "true"); // Set completion flag for level 4
        updateTotalScore(score);

        let finalLives = player.lives;
        if (regeneration && finalLives < maxLivesForLevel) {
          finalLives = Math.min(finalLives + 1, maxLivesForLevel);
        }
        localStorage.setItem("playerLives", finalLives);

        const elapsed = Date.now() - gameStartTime;
        winScreenScore.innerText = `Score: ${score}`;
        winScreenTime.innerText = `Time: ${formatTime(elapsed)}`;
        winScreenLives.innerText = `Lives Remaining: ${finalLives}`;
        winScreen.style.display = "flex";

        document.getElementById('nextLevelBtn').onclick = () => {
          localStorage.setItem("playerScore", score);
          localStorage.setItem("level5Eligible", "true");
          window.location.href = "level5.html";
        };

        document.getElementById('dashboardBtn').onclick = () => {
          window.location.href = "dashboard.html";
        };
      }

      const elapsed = Date.now() - gameStartTime;
      let cooldownInfo = "";
      if (smokeCooldown > 0) {
        cooldownInfo += ` | Smoke: ${Math.ceil(smokeCooldown / 1000)}s`;
      }
      if (freezeCooldown > 0) {
        cooldownInfo += ` | Freeze: ${Math.ceil(freezeCooldown / 1000)}s`;
      }
      hud.innerText = `Coins: ${score} | Lives: ${player.lives} | Time: ${formatTime(elapsed)}${cooldownInfo}`;
    }

    function loop() {
      update();
      draw();
      if (!gameOver) requestAnimationFrame(loop);
    }

    document.addEventListener("keydown", e => {
      keys[e.key] = true;
      if (e.key === "q" || e.key === "Q") {
        if (homingEnabled && homingCooldown <= 0) {
          homingMissiles.push({ x: player.x + 16, y: player.y, vx: 0, vy: -5 });
          homingCooldown = HOMING_COOLDOWN_TIME;
        }
      }
      if (e.key === "m" || e.key === "M") {
        if (minionClones && !minionsSpawned) {
          spawnPlayerMinions();
          minionsSpawned = true;
        }
      }
      if (e.key === "e" || e.key === "E") {
        if (timeFreeze && freezeCooldown <= 0) {
          freezeActive = 10000;
          freezeCooldown = 90000;
        }
      }
      if (e.key === "w" || e.key === "W") {
        if (smokeBomb && smokeCooldown <= 0) {
          smokeActive = 10000;
          smokeCooldown = 20000;
        }
      }
    });
    document.addEventListener("keyup", e => keys[e.key] = false);

    let autoFire = false;
    let autoFireInterval;

    if (minionClones) document.getElementById('minionBtn').style.display = 'block';
    if (timeFreeze) document.getElementById('freezeBtn').style.display = 'block';
    if (smokeBomb) document.getElementById('smokeBtn').style.display = 'block';

    function setupTouchButton(id, key) {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; });
      btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; });
      btn.addEventListener('mousedown', (e) => { e.preventDefault(); keys[key] = true; });
      btn.addEventListener('mouseup', (e) => { e.preventDefault(); keys[key] = false; });
    }

    setupTouchButton('leftBtn', "ArrowLeft");
    setupTouchButton('rightBtn', "ArrowRight");

    document.getElementById('fireBtn').addEventListener('click', () => {
      if (player.cooldown <= 0 && !gameOver) {
        keys[" "] = true;
        setTimeout(() => keys[" "] = false, 50);
      }
    });

    document.getElementById('autoFireBtn').addEventListener('click', () => {
      autoFire = !autoFire;
      document.getElementById('autoFireBtn').textContent = autoFire ? 'Auto-Fire: ON' : 'Auto-Fire: OFF';

      if (autoFire) {
        autoFireInterval = setInterval(() => {
          if (!gameOver && player.cooldown <= 0) {
            keys[" "] = true;
            setTimeout(() => keys[" "] = false, 50);
          }
        }, 200);
      } else {
        clearInterval(autoFireInterval);
      }
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'r' || e.key === 'R') {
        e.preventDefault();
        document.getElementById('autoFireBtn').click();
      }
    });

    document.getElementById('minionBtn').addEventListener('click', () => {
      if (minionClones && !minionsSpawned) {
        spawnPlayerMinions();
        minionsSpawned = true;
      }
    });

    document.getElementById('freezeBtn').addEventListener('click', () => {
      if (timeFreeze && freezeCooldown <= 0) {
        freezeActive = 10000;
        freezeCooldown = 90000;
      }
    });

    document.getElementById('smokeBtn').addEventListener('click', () => {
      if (smokeBomb && smokeCooldown <= 0) {
        smokeActive = 10000;
        smokeCooldown = 20000;
      }
    });

    backDashboardBtn.onclick = () => {
      updateTotalScore(score);
      window.location.href = "dashboard.html";
    };

    spawnAliens();
    loop();
  </script>
</body>
</html>
